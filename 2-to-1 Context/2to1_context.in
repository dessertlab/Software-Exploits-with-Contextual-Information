zero out the ecx register _BREAK move 25 into its lower 8 bits
subtract 8 from the curent byte of the shellcode _BREAK negate the result
move the byte at the address esi + eax into bl _BREAK if the value is equal to 0xaa
if bl is equal to 0xbb _BREAK jump to xordecode
clear the eax register _BREAK move 0x1 into its lowest byte
move the byte at the address esi+eax*1 into bl _BREAK if the result of xor with 0xaa is not zero
move the byte at the address esi+eax*1 into bl _BREAK move it into the byte in edi
zero out the ecx register _BREAK move 0x19 into its lowest byte
push the pointer to stack for later execution _BREAK move it to EDI
move current word from encoded_shellcode to AX _BREAK XOR with 1337, one word at a time
shift encoded_shellcode to right by one bit, one word at a time _BREAK sustract 13 , one word at a time
move the byte at the addrss in esi+ecx+1 to bl _BREAK subtract 0x7
clear the counter _BREAK move 0x1e into the first byte 
in decode move the current byte of the shellcode in the bl register _BREAK xor with 0xBB
move the byte of the shellcode in cl _BREAK xor with 0xAA
move the byte in esi+1 to dl _BREAK shift right by 1
move the byte in eax to bl _BREAK xor with 0xBB
move the byte in eax to cl _BREAK xor with 0xAA
move the byte at address eax to dl _BREAK xor with 0xBB 
mov the word at the address edi+1+ecx into ax _BREAK perform xor with bx
load encoded_shellcode's byte pointed by ESI in al _BREAK swap with next byte value (ESI+1)
perform the xor between ch and the byte in esi+edx _BREAK move it into the byte in esp+eax
NOT operation of current byte in esi _BREAK ADD 0x02 and XOR with 0x97
clear the eax register _BREAK move 22 into the lower byte 
right rotate bl by the contents of cl _BREAK move it into the byte defined by the address esi + eax
Put the LEADER byte to DL _BREAK Copy to AL
shift left 28 bits of EAX which contains the value of Leader on al _BREAK shift right 28
rotate left byte [esi] by 4 _BREAK negate the result
move the byte at the address esi + eax + 1into bl _BREAK move it in the byte address edi
move 0x04030382 in ecx _BREAK subtract 0x03030303
clear the ebx register _BREAK if the value is equal to eax
clear the ebx register _BREAK if the value is not equal to eax
move 0x88998899 in ecx _BREAK subtract 0x1525152A
move esi in eax _BREAK increment
zero out the ecx register _BREAK load the address of esp + 100
perform AND between ax and cx _BREAK if the result not equal bx
zero out the eax register _BREAK move it in ebx and in ecx
increment bl _BREAK if it is less than 0x1f
increment ebx _BREAK if the result is equal edx
add edx to eax _BREAK move in esi
move eax in edx _BREAK right shift by byte 16
subtract 0x28 from esp _BREAK move to ebx
right shift the register edx by 16 _BREAK increment it
move 0x72702f2f in esi _BREAK load in the stack
zero out the register ebx _BREAK if it is equal eax
zero out the register edi _BREAK if it is not equal eax
zero out the register eax _BREAK load in the stack
zero out the register ebx _BREAK load in the stack
move 0x353ffc3b in esi _BREAK add 0x33333333
subtract 8 from esp _BREAK move it in ebx
add 4 to esi _BREAK if the value at its address is equal to edx
move esp in edi _BREAK move in ecx
move 876189623 in edi _BREAK doubles its value
subtract 2 from the byte at the address esi _BREAK negate the result
move in bl the byte at the address [esi+eax*1+0x1] _BREAK move the result in the byte at the address edi
move 0xfff in dx _BREAK increment it
if the byte at the address esi is greater than 0x2 _BREAK jump to L1
increment eax _BREAK repeat
load eax in the stack _BREAK if is equal ebx
zero out ebx _BREAK fill it with eax
move eax in ecx _BREAK load in the stack
add 0x4 in the byte at the address edi _BREAK negate the result
move 0x8b90909d in eax _BREAK negate the result
move 0x9a8dd091 in eax _BREAK negate the result
move 0x969d8cd0 in eax _BREAK negate the result
negate al _BREAK increment
if the byte at the address esi is lower than 0x1 _BREAK jump to L1
subtract 0x9 from the byte at the address esi _BREAK negate the result
load eax in the stack _BREAK repeat
increment ebx _BREAK load in the stack
zero out eax _BREAK if it is equal edx
clear ebx _BREAK move 0x3 in its lowest byte
shift logical right cx a number of times equal to value in al _BREAK negate th result
clear ecx _BREAK move the value at the address esi+1 in its lowest byte
clear eax _BREAK move 5 in its lowest byte
clear ebx _BREAK move the value at the address esi+1 in its lowest byte
move 0xb33fb33f in eax _BREAK subtract 0x3bd04ed 
move bl in the byte at address edi _BREAK XOR with 0xdd
clear ebx _BREAK move 5 in its lowest byte
subtract 0x1 from the byte at the address edi _BREAK negate the result
add 7 to the byte at address edi _BREAK negate the result
load eax in the stack _BREAK clear the register
subtract 3 from the byte at the address edi _BREAK negate the result
clear the register ecx _BREAK move 0x19 in its lowest byte
move the byte at the address esi+ecx+1 in bl _BREAK and subtract 0x7
clear eax register and move in its lower byte 0x3f _BREAK if it is greater than or equal 9
subtract 0x2c3d2dff from eax _BREAK load in the stack
increment ecx _BREAK if is not equal 4
clear ecx _BREAK subtract the result from eax and if it is not zero
clear eax  _BREAK move 0x6 in its lowest byte 
move 0xBEBDBEBD in eax _BREAK negate the result
put the LEADER byte to EDX (DL) _BREAK copy it to eax
move al in cl _BREAK subtract dl
shift left 28 bits of EAX _BREAK shift right 24 the result
move 0xff in bl _BREAK subtract al
move the value at the address esi in bl _BREAK if the XOR with 0xBB is zero
move the value at the address esi in cl _BREAK if the XOR with 0xAA is zero
move the value at the address esi+1 in dl _BREAK shift right 1
move the value at the address eax in bl _BREAK if the XOR with 0xBB is zero
move the value at the address eax in bl and in cl _BREAK if the XOR with 0xAA is not zero
move the value at the address eax in dl _BREAK if the XOR with 0xBB is zero
move the value at the address eax+1 in dl _BREAK move it in the byte at address eax
clear eax _BREAK move 0x2 in its lowest byte
clear ebx _BREAK if it is equal eax
clear eax _BREAK move 0x7 in its lowest byte
clear ecx _BREAK move 0x3 in its lowest byte _BREAK
exchange esi with esp _BREAK exchange it with ebx
move 1666 in bx _BREAK subtract 1634 from it
move 1666 in ax _BREAK subtract 1662 from it
move 1666 in dx _BREAK subtract 15444 from it
subtract ecx from itself _BREAK add 0xb8 to its lowest byte
move the byte at the address edi in the lowest byte of eax _BREAK subtract 0x41
add the byte at the address edi to the lowest byte of eax _BREAK subtract 0x41
decrement esp _BREAK decrement it
XOR between eax and 0x58494741 _BREAK decrement the result
move the value at the address ebp+12 in ecx _BREAK exchange its value with the value at the address ebp+16
shift right edx a byte for 16 _BREAK add the result to eax
subtract ax from itself _BREAK increment it
load the address of bp+0x08 into bx _BREAK move it to the address bp+0x36
load the address of bp+0x36 into bx _BREAK move it to the address bp+0x0b
subtract ax from itself _BREAK move its lowest byte into the address bp+0x07, into the address bp+0x0a and into the address bp+0x31
increment bl _BREAK if its value is below of 0x1f
clear eax _BREAK move 0x42 in its lowest byte
increment ebx _BREAK if its value ie equal edx
move the value ad the address ebp+12 in esi _BREAK move it in ebx
clear ebx _BREAK move in it esi
perform AND between ax and cx _BREAK if the result is not equal to bx
clear eax _BREAK move its lowest byte into the address esi+0x6
move 0x37383633 into edx _BREAK perform XOR with ebx
move  0x343d3141 into edx _BREAK perform XOR with ebx
clear eax _BREAK move its lowest byte into address ebx+0x7
decrement eax _BREAK move the result in esi
move 0x563a1f3e in esi _BREAK add to it 0x21354523
clear eax _BREAK perform XOR between the result with the value at the address edi
load the address esi+0xc in ebx _BREAK move it into the value to the address esi+0x2c
move the valute at the address esi into al _BREAK decrement the result
exchange ebx and eax _BREAK repeat
add the value at the address ebx to eax _BREAK repeat
add the value at the address eax+0x575188a to ecx _BREAK move 0x303020a in the result
perform XOR between the value ad the address eax and ah _BREAK perform AND between the result and the value at the address eax
perform AND between ah and the value at the address eax _BREAK repeat
perform OR between ah and dl _BREAK perform OR between the value at the address [esi+0xa] and the result
move esp in the value at the address eax _BREAK perform AND with ah
move esp in ecx _BREAK move it in the value at the address edx
exchange ebp and eax _BREAK add to result the value at the address ebx
clear edx _BREAK increment it
clear eax _BREAK increment it
move ecx in ebx _BREAK move it in eax
negate bl _BREAK perform XOR between the result and al
load the address edi+0x8 in esi _BREAK move the result in the value at the address edi+0x1e
clear esi _BREAK load in it the address edi+0x10
clear edi _BREAK increment it
negate edi _BREAK add the result to eax
load the address esi+0xf in ebx _BREAK move it in the value at the address esi+0x16
subtract 0xffffffdf from edi _BREAK load it in the stack
move the byte at the address edi in al _BREAK subtract 0x41 from it
add the byte at the address edi to al _BREAK subtract 0x41 from it
move 0xef in al _BREAK negate the result
clear ecx _BREAK if the register is equal eax
clear ebx _BREAK move edi in it
increment edx _BREAK shift left 10 the register
exchange ecx and eax _BREAK repeat
add eax to the value at the address ecx _BREAK repeat
load the address esi+0x8 in ebx _BREAK move the register in the value at the address esi+0x4d
increment esp _BREAK repeat
move esp in ecx _BREAK subtract edx from the register
move ecx in edi _BREAK add eax to it
load esi in the stack _BREAK decrement the register
exchange edx with eax _BREAK decrement it
move esi in edi _BREAK subtract 34 from it
move the value at the address esp+ecx in ebx _BREAK move the register in edx
move the value at the address edx in ax _BREAK if the register in not equal 0x5a4d
move the value at the address ebx+0x3c in edi _BREAK add ebx to the register
add ebx to edi _BREAK add 4 to the result
move the byte at the address eax+ecx+5 in bl _BREAK if the register in equal 0
move the value at the address ebx+0x78 in edi _BREAK add ebx to the register
move the value at the address edi+0x20 in eax _BREAK add ebx to the register
move the value at the address eax+ecx*4 in esi _BREAK add ebx to the register
rotate edx 13 bits to the right _BREAK add eax to result
move the the value at the address edx+4*ecx in eax _BREAK add ebx to result
move 0xff9a879b into eax _BREAK negate the register
move 0x1111 into bx _BREAK subtract 0x1010 from it
move 0x111111A9 into esi _BREAK subtract 0x11111111 from the register
subtract 0x10 from esp _BREAK move the result in ebx
move 0x3b1 in cx _BREAK add 0x50 to the register
move 0x12 in dl _BREAK add 0x3 to the register
move 0xffe in dx _BREAK increment the register
rotate left byte [esi] by 4 _BREAK negate the result
move the byte at the address esi+eax+1 in bl _BREAK move the register in the byte at the address edi
move the byte at the address esi+eax+1 in bl _BREAK move the register in the byte at the address edi
move 0x222933f0 in esi _BREAK add 0x3f3f3f3f to it
clear ebx _BREAK if eax is equal to the register
load the address esi+14 in ebx _BREAK move the register in the value at the address esi+39
load the address esi+23 in ebx _BREAK move the register in the value at the address esi+43
clear eax _BREAK move 0x5 into its lowest byte
clear ecx _BREAK move 2 into its lowest byte
clear ecx _BREAK move 0x3 into its lowest byte
move the byte at the address esi+eax*3 into bl _BREAK if the result of xor with 0xaa is not zero
add 4 to esi _BREAK if the value at its address is equal to eax
move the value at the address ebp in ecx _BREAK exchange its value with the value at the address ebp+12
clear ecx _BREAK subtract the result from ebx and if it is not zero
load ebx in the stack _BREAK clear the register
if the byte at the address esi+eax*3 is greater than 0x2 _BREAK jump to L1
decrement ecx _BREAK move the result in esi
load the address of bp+0x36 into bx _BREAK move it to the address bp+0x8
move the value at the address eax in bl and in cl _BREAK if the XOR with 0xDD is not zero
shift logical right ax a number of times equal to value in al _BREAK negate the result
if bl is equal to 0xbb _BREAK jump to xordecode 
move the byte at the address esi+ebx*1 into bl _BREAK if the result of xor with 0xaa is not zero 
move the byte at the adderss in esi+ecx+1 to bl _BREAK subtract 0x9
in decode move the current byte of the shellcode in the al register _BREAK xor with 0xDD
move the byte of the shellcode in bl _BREAK xor with 0xAA
move the byte in esi+3 to dl _BREAK shift right by 1
move the byte in ebx to al _BREAK xor with 0xBB
move the byte in eax to bl _BREAK xor with 0xAA
move the byte at address eax to bl _BREAK xor with 0xBB 
move the word at the address edi+1+ecx into ax _BREAK perform xor between bx and the register
load encoded_shellcode's byte pointed by ESI in al _BREAK swap with next byte value (ESI+1)
rotate left byte [esi] by 4 _BREAK negate the result
move 0x04030382 in ecx _BREAK subtract 0x03030303
clear the eax register _BREAK if the value is equal to ecx
clear the ebx register _BREAK if the value is not equal to ecx
perform AND between bx and cx _BREAK if the result not equal ax
increment al _BREAK if it is less than 0x1f
increment ebx _BREAK if the result is equal edx
move ebx in edx _BREAK right shift by byte 16
move 0x72702f2f in esi _BREAK load in the stack
zero out the register eax _BREAK if it is equal ebx
zero out the register edi _BREAK if it is not equal ebx
zero out the register ecx _BREAK load in the stack
add 4 to esi _BREAK if the value at its address is equal to ebx
move 876198623 in edi _BREAK doubles its value
if the byte at the address esi is greater than 0x2 _BREAK jump to L1
increment ecx _BREAK repeat
load ecx in the stack _BREAK if is equal eax
move 0x8b90909d in ebx _BREAK negate the result
move 0x9a8dd091 in ecx _BREAK negate the result
move 0x989d7cd0 in eax _BREAK negate the result
if the byte at the address esi is lower than 0x1 _BREAK jump to L1
zero out eax _BREAK if it is equal edx
move 0xb33fb33f in ebx _BREAK subtract 0x3bd04ed from it
load eax in the stack _BREAK clear the register
clear eax register and move in its lower byte 0x3f _BREAK if it is greater than or equal 5
increment ecx _BREAK if is not equal 7
clear ecx _BREAK subtract the result from ebx and if it is not zero
shift left 28 bits of eax _BREAK shift right 24 the result
move 0xff in bl _BREAK subtract al
move the value at the address esi+1 in bl _BREAK if the XOR with 0xBB is zero
move the value at the address esi+eax*1 in cl _BREAK if the XOR with 0xAA is zero
move the value at the address esi+1 in dl _BREAK shift right 1 
move the value at the address eax in cl _BREAK if the XOR with 0xBB is zero
move the value at the address eax in bl and in cl _BREAK if the XOR with 0xDD is not zero
move the value at the address eax in dl _BREAK if the XOR with 0xBB is not zero
clear eax _BREAK if it is equal ecx
clear eax _BREAK move 0x3 in its lowest byte
move the byte at the address edi in the lowest byte of eax _BREAK subtract 0x43
add the byte at the address edi to the lowest byte of eax _BREAK subtract 0x41
decrement esi _BREAK decrement it
increment bl _BREAK if its value is below of 0x1f
increment ebx _BREAK if its value ie equal edx
perform AND between ax and bx _BREAK if the result is not equal to cx
move the value at the address esi into al _BREAK decrement the result
exchange ecx and eax _BREAK repeat
perform AND between ah and the value at the address eax+ecx _BREAK repeat
move esp in the value at the address eax+ebx*2 _BREAK perform AND with ah
negate bl _BREAK perform XOR between the result and al
move the byte at the address edi in al _BREAK subtract 0x41 from it
add the byte at the address edi+ecx to al _BREAK subtract 0x41 from it
clear ecx _BREAK if the register is equal eax
increment edx _BREAK shift left 9 the register
exchange ebx with eax _BREAK decrement it
move the value at the address esp+ecx in ebx _BREAK move the register in edx
move the value at the address edx in ax _BREAK if the register in not equal 0x5a7d
move the byte at the address eax+ecx*5 in bl _BREAK if the register in equal 0
move the value at the address edi+0x20 in eax _BREAK add ebx to the register
move the the value at the address edx+4*ecx in ebx _BREAK add eax to result
move 0x1111 into cx _BREAK subtract 0x1010 from it
rotate left byte [esi] by 4 _BREAK negate the result
move the byte at the address esi+eax+1 in bl _BREAK move the register in the byte at the address edi
move the byte at the address esi+eax*2 in bl _BREAK move the register in the byte at the address edi
clear ecx _BREAK if eax is equal to the register
move the byte at the address esi+eax into bl _BREAK if the result of xor with 0xbb is not zero 
add 5 to esi _BREAK if the value at its address is equal to eax
clear eax _BREAK subtract the result from ebx and if it is not zero
load ebx in the stack _BREAK clear the register
if the byte at the address esi+eax*5 is greater than 0x2 _BREAK jump to L1
move the value at the address eax in bl and in cl _BREAK if the XOR with 0xBB is not zero
move the byte at the address esi + eax into cl _BREAK if the value is equal to 0xaa
if cl is equal to 0xbb _BREAK jump to xordecode 
move the byte at the addrss in esi+ecx+1 to al _BREAK subtract 0x7
move the byte in esi+1 to bl _BREAK shift right by 1
move the byte in eax to dl _BREAK xor with 0xBB
move the byte in eax to dl _BREAK xor with 0xAA
mov the word at the address edi into ax _BREAK perform xor with bx
load encoded_shellcode's byte pointed by ESI in dl _BREAK swap with next byte value (ESI+1)
rotate left byte [edi] by 4 _BREAK negate the result
move 0x04030382 in eax _BREAK subtract 0x03030303
clear the edx register _BREAK if the value is equal to eax
clear the edi register _BREAK if the value is not equal to edx
perform the and between ax and bx _BREAK if the result not equal cx
increment dl _BREAK if it is less than 0x1f
increment edx _BREAK if the result is equal eax
move ecx into edx _BREAK right shift by byte 16
move 0x72702f2f in edi _BREAK load in the stack
clear edx _BREAK if it is equal ecx
zero out the register esi _BREAK if it is not equal eax
add 4 to edi _BREAK if the value at its address is equal to edx
increment edi _BREAK repeat
load edx in the stack _BREAK if is equal edx
move 0x9a8dd090 in edx _BREAK negate the result
if the byte at the address edi is lower than 0x1 _BREAK jump to L7
load edx in the stack _BREAK clear the register
clear ecx _BREAK subtract the result from edx and if it is not zero
shift left by 28 bits of edx _BREAK shift right by 24 the result
subtract bl from the register _BREAK move 0xff in dl
move the value at the address esi in dl _BREAK shift right 1 
move the value at the address eax in cl _BREAK if the xor between the result and 0xBB is zero
add the byte at the address esi to the lowest byte of eax _BREAK subtract 0x41
perform the and between eax and ebx _BREAK repeat
negate dl _BREAK perform the xor between the result and al
add the byte at the address edi+esi to bl _BREAK subtract 0x41 from it
exchange eax and ebx _BREAK repeat
increment edx _BREAK repeat
load edi in the stack _BREAK decrement the register
move the value at the address esp+ecx in eax _BREAK move the register in edx
move the the value at the address edx+ecx in eax _BREAK add eax to result
move the byte at the address eax in cl _BREAK move the register in the byte at the address esi
load ecx in the stack _BREAK clear the register
clear eax _BREAK subtract the result from ecx and if it is not zero
add 4 to edi _BREAK if the value at its address is equal to eax
move the byte at the address esi into bl _BREAK if the result of xor with 0xaa is not zero
clear edx _BREAK if eax is equal to the register
move the byte at the address esi in cl _BREAK move the register in the byte at the address edi 
move 0x1011 into ax _BREAK subtract 0x1000 from it
move the byte at the address eax+ecx in cl _BREAK if the register in equal 0
move edx in ax _BREAK if the register in not equal 0x5a7d 
negate cl _BREAK perform the xor between the result and al _BREAK move the result in the value at the address in edi+ebx
move the valute at the address esi into dl _BREAK decrement the result _BREAK move it in the value at the address esi
perform the and between bx and cx _BREAK if the result is not equal to ax
increment dl _BREAK if its value is below of 0xf3
move the value at the address ecx+ebx in al _BREAK if the xor with 0xBB is zero
move esi to bl _BREAK if the xor with 0xAA is zero
move 0xb33fb33f in ecx _BREAK subtract 0x3bd04ed
move 0x9a8dd110 in edx _BREAK negate the result
move the byte at the address edi to cl _BREAK swap with next byte value (ESI+1)
move the byte at the address esi+eax into dl _BREAK if the result of xor with 0xbb is not zero
move eax in ecx _BREAK right shift by byte 4
move 0x72702f2f in edx _BREAK load in the stack
if the byte at the address esi is greater than 0x1 _BREAK jump to L3
perform the or between eax and ah _BREAK perform the and between the result and eax
perform the and between ah and the value at the address eax _BREAK repeat
move the byte at the address edi into dl _BREAK subtract 0x43 from it
increment edx _BREAK repeat
load ebx in the stack _BREAK decrement the register
move the value at the address esp in ecx _BREAK move the register in edx
move the the value at the address edx+4*ecx in edx _BREAK add ebx to result
move 0xff in dl _BREAK subtract al
move the byte at the address edi into bl _BREAK subtract 0x43
move 0x04030382 in ecx _BREAK subtract 0x03030327
shift left by 4 bits of ecx _BREAK shift right by 2 the result