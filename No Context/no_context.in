zero out the ecx register 
move 25 into its lower 8 bits
subtract 8 from the curent byte of the shellcode
negate the result
move the byte at the address esi + eax into bl
if the value is equal to 0xaa
jump to shellcode
if bl is equal to 0xbb
jump to xordecode 
else jump to notdecode
clear the eax register 
move 0x1 into its lowest byte
move the byte at the address esi+eax*1 into bl
if the result of xor with 0xaa is not zero 
jump to EncodedShellcode
move the byte at the address esi+eax*1 into bl
move it into the byte in edi
zero out the ecx register 
move 0x19 into its lowest byte
push the pointer to stack for later execution
move it to EDI
move current word from encoded_shellcode to AX
XOR with 1337, one word at a time
shift encoded_shellcode to right by one bit, one word at a time
subtract 13 , one word at a time
move the byte at the addrss in esi+ecx+1 to bl
subtract 0x7
move it into the byte in esi+ecx
clear the counter 
move 0x1e into the first byte 
in decode move the current byte of the shellcode in the bl register
xor with 0xBB
if is zero jump to formatting
move the byte of the shellcode in cl
xor with 0xAA
if is zero jump to shift_decode
move the byte in esi+1 to dl
shift right by 1
move it into the byte in esi+1
move the byte in eax to bl
xor with 0xBB
if is zero jump to encoded
move the byte in eax to cl
xor with 0xAA
if the result is not zero jump to Next_Cycle
move the byte at address eax to dl
xor with 0xBB 
if the result is zero jump to Next_Cycle
mov the word at the address edi+1+ecx into ax
perform xor with bx
move it into the word in edi
load encoded_shellcode's byte pointed by ESI in al
swap with next byte value (ESI+1)
load swapped byte to location pointed by ESI
perform the xor between ch and the byte in esi+edx
move it into the byte in esp+eax
NOT operation of current byte in esi
ADD 0x02 and XOR with 0x97
ADD 0x10 and XOR with 0x88
clear the eax register
move 22 into the lower byte 
right rotate bl by the contents of cl
move it into the byte defined by the address esi + eax
Put the LEADER byte to DL
Copy to AL
shift left 28 bits of EAX which contains the value of Leader on al
shift right 28
rotate left byte [esi] by 4
negate the result
add 2
move the byte at the address esi + eax + 1 into bl
move it in the byte at address edi
move 0x04030382 in ecx
subtract 0x03030303
load in the stack
clear the ebx register
if the value is equal to eax
jump to download
clear the ebx register
if the value is not equal to eax
jump to retry
move 0x88998899 in ecx
subtract 0x1525152A
move esi in eax
increment
zero out the ecx register 
load the address of esp + 100
perform AND between ax and cx
if the result not equal bx
jump to .l3
zero out the eax register 
move it in ebx and in ecx
increment bl
if it is less than 0x1f
jump to 0xf3
increment ebx
if the result is equal edx
jump to 0x8
add edx to eax
move in esi
move eax in edx
right shift by byte 16
add to eax
subtract 0x28 from esp
move to ebx
right shift the register edx by 16
increment it
move 0x72702f2f in esi
load in the stack
zero out the register
zero out the register ebx
if it is equal eax
jump to exit
zero out the register edi
if it is not equal eax
jump to 804808e
zero out the register eax
load in the stack
zero out the register ebx
load in the stack
increment
move 0x353ffc3b in esi
add 0x33333333
subtract 8 from esp
move it in ebx
add 4 to esi
if the value at its address is equal to edx
jump to find_egg
move esp in edi
move in ecx
move 876189623 in edi
doubles its value
load in the stack
subtract 2 from the byte at the address esi
negate the result
move in bl the byte at the address [esi+eax*1+0x1]
move the result in the byte at the address edi
move 0xfff in dx
increment it
if the byte at the address esi is greater than 0x2
jump to L1
else add 0x2
increment eax
repeat
repeat
load eax in the stack
if is equal ebx
jump to child
zero out ebx
fill it with eax
move eax in ecx
load in the stack
add 0x4 in the byte at the address edi
negate the result
move 0x8b90909d in eax
negate the result
load in the stack
move 0x9a8dd091 in eax
negate the result
load in the stack
move 0x969d8cd0 in eax
negate the result
load in the stack
negate al
increment
if the byte at the address esi is lower than 0x1
jump to L1
else subtract 0x1
subtract 0x9 from the byte at the address esi
negate the result
load eax in the stack
repeat
increment ebx
load in the stack
zero out eax
if it is equal edx
jump to l3
clear ebx
move 0x3 in its lowest byte
shift logical right cx a number of times equal to value in al
negate the result
clear ecx
move the value at the address esi+1 in its lowest byte
clear eax
move 5 in its lowest byte
clear ebx
move the value at the address esi+1 in its lowest byte
move 0xb33fb33f in eax
subtract 0x3bd04ed 
load in the stack
move bl in the byte at address edi
XOR with 0xdd
clear ebx
move 5 in its lowest byte
subtract 0x1 from the byte at the address edi
negate the result
add 7 to the byte at address edi
negate the result
load eax in the stack
clear the register
move 1 in its lowest byte
subtract 3 from the byte at the address edi 
negate the result
clear the register ecx
move 0x19 in its lowest byte
move the byte at the address esi+ecx+1 in bl
and subtract 0x7
clear eax register and move in its lower byte 0x3f
if it is greater than or equal 9
jump to l1
subtract 0x2c3d2dff from eax
load in the stack
increment ecx
if is not equal 4
jump to loop
clear ecx
subtract the result from eax and if it is not zero
jump to cleanup
clear eax
move 0x6 in its lowest byte 
move 0xBEBDBEBD in eax
negate the result
put the LEADER byte to EDX (DL)
copy it to eax
move al in cl
subtract dl
shift left 28 bits of EAX
shift right 24 the result
add ebx to result
move 0xff in bl
subtract al
move the result in the byte at the address edi
move the value at the address esi in bl
if the XOR with 0xBB is zero
jump to formatting
move the value at the address esi in cl
if the XOR with 0xAA is zero
jump to shift_decode
move the value at the address esi+1 in dl
shift right 1 
move the result in the byte at the address esi+1
move the value at the address eax in bl
if the XOR with 0xBB is zero
jump to encoded
move the value at the address eax in bl and in cl
if the XOR with 0xAA is not zero
jump to Next_Cycle
move the value at the address eax in dl
if the XOR with 0xBB is zero
jump to Next_Cycle
move the value at the address eax+1 in dl
move it in the byte at address eax
clear eax
move 0x2 in its lowest byte
clear ebx
if it is equal eax
jump to child
clear eax
move 0x7 in its lowest byte
clear ecx
move 0x3 in its lowest byte
decrement it
exchange esi with esp
exchange it with ebx
move 1666 in bx
subtract 1634 from it
move 1666 in ax
subtract 1662 from it
move 1666 in dx
subtract 15444 from it
subtract ecx from itself
add 0xb8 to its lowest byte
move the byte at the address edi in the lowest byte of eax
subtract 0x41
shift left 4
add the byte at the address edi to the lowest byte of eax
subtract 0x41
move the result to the byte at the address esi
decrement esp
decrement it
repeat
XOR between eax and 0x58494741
decrement the result
move the value at the address ebp+12 in ecx
exchange its value with the value at the address ebp+16
shift right edx a byte for 16
add the result to eax
subtract ax from itself
increment it
load the address of bp+0x08 into bx
move it to the address bp+0x36
load the address of bp+0x36 into bx
move it to the address bp+0x0b
subtract ax from itself
move its lowest byte into the address bp+0x07, into the address bp+0x0a and into the address bp+0x31
increment bl
if its value is below of 0x1f
jump to 0xf3
clear eax
move 0x42 in its lowest byte
increment ebx
if its value ie equal edx
jump to 0x8
move the value ad the address ebp+12 in esi
move it in ebx
clear ebx
move in it esi
perform AND between ax and cx
if the result is not equal to bx
jump to .l3
clear eax
move its lowest byte into the address esi+0x6
move 0x37383633 into edx
perform XOR with ebx
move 0x343d3141 into edx
perform XOR with ebx
clear eax
move its lowest byte into address ebx+0x7
decrement eax
move the result in esi
move 0x563a1f3e in esi
add to it 0x21354523
clear eax
perform XOR between the result with the value at the address edi
load the address esi+0xc in ebx
move it into the value to the address esi+0x2c
move the valute at the address esi into al
decrement the result
move it in the value at the address esi
exchange ebx and eax
repeat
repeat
add the value at the address ebx to eax
repeat
add the value at the address eax+0x575188a to ecx
move 0x303020a in the result
perform OR between the value at the address eax and ah
perform AND between the result and the value at the address eax
repeat
perform AND between ah and the value at the address eax
repeat
repeat
perform OR between ah and dl
perform OR between the value at the address [esi+0xa] and the result
move esp in the value at the address eax
perform AND with ah
repeat
move esp in ecx
move it in the value at the address edx
exchange ebp and eax
add to result the value at the address ebx
clear edx
increment it
clear eax
increment it
move ecx in ebx
move it in eax
negate bl
perform XOR between the result and al
move the result in the value at the address in edi+ecx
load the address edi+0x8 in esi
move the result in the value at the address edi+0x1e
clear esi
load in it the address edi+0x10
clear edi
increment it
negate edi
add the result to eax
load the address esi+0xf in ebx
move it in the value at the address esi+0x16
subtract 0xffffffdf from edi
load it in the stack
move the byte at the address edi in al
subtract 0x41 from it
shift left 4 the result
add the byte at the address edi to al
subtract 0x41 from it
move the result in the byte at the address esi
move 0xef in al
negate the result
clear ecx
if the register is equal eax
jump to 0x83
clear ebx
move in it edi
increment edx
shift left 10 the register
increment it
exchange ecx and eax
repeat
repeat
add eax to the value at the address ecx
repeat
load the address esi+0x8 in ebx
move the register in the value at the address esi+0x4d
increment esp
repeat
repeat
move esp in ecx
subtract edx from the register
move ecx in edi
add eax to it
load esi in the stack
decrement the register
increment the register
exchange edx with eax
decrement it
move the result in ecx
move esi in edi
subtract 34 from it
move the value at the address esp+ecx in ebx
move the register in edx
shift it right 28 
move the value at the address edx in ax
if the register in not equal 0x5a4d
jump findMZ
move the value at the address ebx+0x3c in edi
add ebx to the register
add ebx to edi
add 4 to the result
move the byte at the address eax+ecx+5 in bl
if the register in equal 0
jump foundPtr
move the value at the address ebx+0x78 in edi
add ebx to the register
move the value at the address edi+0x20 in eax
add ebx to the register
move the result in the value at the address ebp+4
move the value at the address eax+ecx*4 in esi
add ebx to the register
rotate edx 13 bits to the right
add eax to result
move the the value at the address edx+4*ecx in eax
add ebx to result
move it in the value at the address esp+0x1c
move 0xff9a879b into eax
negate the register
move 0x1111 into bx
subtract 0x1010 from it
move the result in the word at the address esp+0x3c
move 0x111111A9 into esi
subtract 0x11111111 from the register
subtract 0x10 from esp
move the result in ebx
move 0x3b1 in cx
add 0x50 to the register
move 0x12 in dl
add 0x3 to the register
move 0xffe in dx
increment the register
rotate left byte [esi] by 4
negate the result
add 4 to the result
move the byte at the address esi+eax+1 in bl
move the register in the byte at the address edi
perform XOR between it and 0XDD
move the byte at the address esi+eax+1 in bl
move the register in the byte at the address edi
negate the result
move 0x222933f0 in esi
add 0x3f3f3f3f to it
clear ebx
if eax is equal to the register
jump to download
load the address esi+14 in ebx
move the register in the value at the address esi+39
load the address esi+23 in ebx
move the register in the value at the address esi+43
clear eax
move 0x5 into its lowest byte
clear ecx
move 2 into its lowest byte
clear ecx
move 0x3 into its lowest byte
move the byte at the address esi+eax*3 into bl
if the result of xor with 0xaa is not zero 
jump to shellcode
add 4 to esi
if the value at its address is equal to eax
jump to find_egg
move the value at the address ebp in ecx
exchange its value with the value at the address ebp+12
clear ecx
subtract the result from ebx and if it is not zero
jump to clean
load ebx in the stack
clear the register
move 1 in its lowest byte
if the byte at the address esi+eax*3 is greater than 0x2
jump to L1
else add 0x2
decrement ecx
move the result in esi
load the address of bp+0x36 into bx
move it to the address bp+0x8
move the value at the address eax in bl and in cl
if the XOR with 0xDD is not zero
jump to Cycle
shift logical right ax a number of times equal to value in al
negate the result
if bl is equal to 0xbb
jump to xordecode 
else jump to notdecode
move the byte at the address esi+ebx*1 into bl
if the result of xor with 0xaa is not zero 
jump to EncodedShellcode
move the byte at the adderss in esi+ecx+1 to bl
subtract 0x9
move it into the byte in esi+eax
"in decode move the current byte of the shellcode in the al register
"
xor with 0xDD
if is zero jump to format
move the byte of the shellcode in bl
xor with 0xAA
if is zero jump to shift
move the byte in esi+3 to dl
shift right by 1
move it into the byte in esi+3
move the byte in ebx to al
xor with 0xBB
if is zero jump to encodedtwo
move the byte in eax to bl
xor with 0xAA
if the result is not zero jump to Next
move the byte at address eax to bl
xor with 0xBB 
if the result is zero jump to CycleNext
move the word at the address edi+1+ecx into ax
perform xor between bx and the register
move it into the word in edi+1
load encoded_shellcode's byte pointed by ESI in al
swap with next byte value (ESI+1)
load swapped byte to location pointed by ESI+1
rotate left byte [esi] by 4
negate the result
add 5
move 0x04030382 in ecx
subtract 0x03030303
load in the stack
clear the eax register
if the value is equal to ecx
jump to downloadtwo
clear the ebx register
if the value is not equal to ecx
jump to retrytwo
perform AND between bx and cx
if the result not equal ax
jump to .l7
increment al
if it is less than 0x1f
jump to 0xf4
increment ebx
if the result is equal edx
jump to 0x9
move ebx in edx
right shift by byte 16
add to ebx
move 0x72702f2f in esi
load in the stack
clear the register
zero out the register eax
if it is equal ebx
jump to exittwo
zero out the register edi
if it is not equal ebx
jump to 804800e
zero out the register ecx
load in the stack
increment
add 4 to esi
if the value at its address is equal to ebx
jump to find_eggtwo
move 876198623 in edi
doubles its value
load in the stack
if the byte at the address esi is greater than 0x2
jump to L1
else add 0x5
increment ecx
repeat
repeat
load ecx in the stack
if is equal eax
jump to childtwo
move 0x8b90909d in ebx
negate the result
load in the stack
move 0x9a8dd091 in ecx
negate the result
load in the stack
move 0x989d7cd0 in eax
negate the result
load in the stack
if the byte at the address esi is lower than 0x1
jump to L1
else subtract 0x2
zero out eax
if it is equal edx
jump to l5
move 0xb33fb33f in ebx
subtract 0x3bd04ed from it
load in the stack
load eax in the stack
clear the register
move 7 in its lowest byte
clear eax register and move in its lower byte 0x3f
if it is greater than or equal 5
jump to l2
increment ecx
if is not equal 7
jump to loop
clear ecx
subtract the result from ebx and if it is not zero
jump to cleanuptwo
shift left 28 bits of eax
shift right 24 the result
add ecx to result
move 0xff in bl
subtract al
move the result in the byte at the address edi+1
move the value at the address esi+1 in bl
if the XOR with 0xBB is zero
jump to formattingtwo
move the value at the address esi+eax*1 in cl
if the XOR with 0xAA is zero
jump to shift_decodetwo
move the value at the address esi+1 in dl
shift right 1 
move the result in the byte at the address esi+eax*2
move the value at the address eax in cl
if the XOR with 0xBB is zero
jump to encodedth
move the value at the address eax in bl and in cl
if the XOR with 0xDD is not zero
jump to Next_Cycle
move the value at the address eax in dl
if the XOR with 0xBB is not zero
jump to Next_Cycle
clear eax
if it is equal ecx
jump to child
clear eax
move 0x3 in its lowest byte
decrement it
move the byte at the address edi in the lowest byte of eax
subtract 0x43
shift left 7
add the byte at the address edi to the lowest byte of eax
subtract 0x41
move the result to the byte at the address esi+ebx
decrement esi
decrement it
repeat
increment bl
if its value is below of 0x1f
jump to 0xf5
increment ebx
if its value ie equal edx
jump to 0x9
perform AND between ax and bx
if the result is not equal to cx
jump to .l8
move the value at the address esi into al
decrement the result
move it in the value at the address esi+ecx
exchange ecx and eax
repeat
repeat
perform AND between ah and the value at the address eax+ecx
repeat
repeat
move esp in the value at the address eax+ebx*2
perform AND with ah
repeat
negate bl
perform XOR between the result and al
move the result in the value at the address in edi
move the byte at the address edi in al
subtract 0x41 from it
shift left 2 the result
add the byte at the address edi+ecx to al
subtract 0x41 from it
move the result in the byte at the address esi+ecx
clear ecx
if the register is equal eax
jump to 0x85
increment edx
shift left 9 the register
increment it
exchange ebx with eax
decrement it
move the result in ecx
move the value at the address esp+ecx in ebx
move the register in edx
shift it right 24
move the value at the address edx in ax
if the register in not equal 0x5a7d
jump findMZM
move the byte at the address eax+ecx*5 in bl
if the register in equal 0
jump foundPtrM
move the value at the address edi+0x20 in eax
add ebx to the register
move the result in the value at the address ebp+eax*4
move the the value at the address edx+4*ecx in ebx
add eax to result
move it in the value at the address esp+0x1c
move 0x1111 into cx
subtract 0x1010 from it
move the result in the word at the address esp+0x3c
rotate left byte [esi] by 4
negate the result
add 8
move the byte at the address esi+eax+1 in bl
move the register in the byte at the address edi
perform XOR between it and 0XAA
move the byte at the address esi+eax*2 in bl
move the register in the byte at the address edi
negate the result
clear ecx
if eax is equal to the register
jump to downloadtwo
move the byte at the address esi+eax into bl
if the result of xor with 0xbb is not zero 
jump to shellcodetwo
add 5 to esi
if the value at its address is equal to eax
jump to find_eggtwo
clear eax
subtract the result from ebx and if it is not zero
jump to cleantwo
load ebx in the stack
clear the register
move 7 in its lowest byte
if the byte at the address esi+eax*5 is greater than 0x2
jump to L1
else add 0x2
move the value at the address eax in bl and in cl
if the XOR with 0xBB is not zero
jump to Cycle
move the byte at the address esi + eax into cl
if the value is equal to 0xaa
jump to shellcode
if cl is equal to 0xbb
jump to xordecode 
else jump to nodecode
move the byte at the addrss in esi+ecx+1 to al
subtract 0x7
move it into the byte in esi+ecx
move the byte in esi+1 to bl
shift right by 1
move it into the byte in esi+1
move the byte in eax to dl
xor with 0xBB
if is zero jump to encod
move the byte in eax to dl
xor with 0xAA
if the result is not zero jump to CycleProx
mov the word at the address edi into ax
perform xor with bx
move it into the word in edi+1
load encoded_shellcode's byte pointed by ESI in dl
swap with next byte value (ESI+1)
load swapped byte to location pointed by ESI
rotate left byte [edi] by 4
negate the result
add 2
move 0x04030382 in eax
subtract 0x03030303
load in the stack
clear the edx register
if the value is equal to eax
jump to dld
clear the edi register
if the value is not equal to edx
jump to ret
perform the and between ax and bx
if the result not equal cx
jump to l4
increment dl
if it is less than 0x1f
jump to 0xf3
increment edx
if the result is equal eax
jump to 0x81
move ecx into edx
right shift by byte 16
add to ebx
move 0x72702f2f in edi
load in the stack
zero out the register
clear edx 
if it is equal ecx
jump to ext
zero out the register esi
if it is not equal eax
jump to 804808e
add 4 to edi
if the value at its address is equal to edx
jump to find
increment edi
repeat
repeat
load edx in the stack
if is equal edx
jump to child
move 0x9a8dd090 in edx
negate the result
load in the stack
if the byte at the address edi is lower than 0x1
jump to L7
else subtract 0x1
load edx in the stack
clear the register
move 4 in its lowest byte
clear ecx
subtract the result from edx and if it is not zero
jump to clean
shift left by 28 bits of edx
shift right by 24 the result
add ebx to result
move 0xff in dl
subtract bl from the register
move the result in the byte at the address edi
move the value at the address esi in dl
shift right 1 
move the result in the byte at the address esi
move the value at the address eax in cl
if the xor between the result and 0xBB is zero
jump to encod
add the byte at the address esi to the lowest byte of eax
subtract 0x41
move the result to the byte at the address edi
perform the and between eax and ebx
repeat
repeat
negate dl
perform the xor between the result and al
move the result in the value at the address in ecx
add the byte at the address edi+esi to bl
subtract 0x41 from it
move the result in the byte at the address esi
exchange eax and ebx
repeat
repeat
increment edx
repeat
repeat
load edi in the stack
decrement the register
increment the register
move the value at the address esp+ecx in eax
move the register in edx
shift it right by 4 
move the the value at the address edx+ecx in eax
add eax to result
move it in the value at the address esp+0x1c
move the byte at the address eax in cl
move the register in the byte at the address esi
perform the xor between it and 0XDD
load ecx in the stack
clear the register
move 1 in its lowest byte
clear eax
subtract the result from ecx and if it is not zero
jump to new
add 4 to edi
if the value at its address is equal to eax
jump to label
move the byte at the address esi into bl
if the result of xor with 0xaa is not zero 
jump to label2
clear edx
if eax is equal to the register
jump to downlo
move the byte at the address esi in cl
move the register in the byte at the address edi
perform the xor between it and 0XDD
move 0x1011 into ax
subtract 0x1000 from it
move the result in the word at the address esp
move the byte at the address eax+ecx in cl
if the register in equal 0
jump found
move edx in ax
if the register in not equal 0x5a7d
jump findS
negate cl
perform the xor between the result and al
move the result in the value at the address in edi+ebx
move the valute at the address esi into dl
decrement the result
move it in the value at the address esi
perform the and between bx and cx
if the result is not equal to ax
jump to l27
increment dl
if its value is below of 0xf3
jump to 0x1f
move the value at the address ecx+ebx in al
if the xor with 0xBB is zero
jump to advance
move esi to bl
if the xor with 0xAA is zero
jump to form
move 0xb33fb33f in ecx
subtract 0x3bd04ed 
load in the stack
move 0x9a8dd110 in edx
negate the result
load in the stack
move the byte at the address edi to cl
swap with next byte value (ESI+1)
load swapped byte to location pointed by ESI
move the byte at the address esi+eax into dl
if the result of xor with 0xbb is not zero 
jump to shencoded
move eax in ecx
right shift by byte 4
add to eax
move 0x72702f2f in edx
load in the stack
zero out the register
if the byte at the address esi is greater than 0x1
jump to L3
else add 0x1
perform the or between eax and ah
perform the and between the result and eax
repeat
perform the and between ah and the value at the address eax
repeat
repeat
move the byte at the address edi into dl
subtract 0x43 from it
shift left 2 the result
increment edx
repeat
repeat
load ebx in the stack
decrement the register
increment the register
move the value at the address esp in ecx
move the register in edx
shift it right 4
move the the value at the address edx+4*ecx in edx
add ebx to result
move it in the value at the address esp+0x1c
move 0xff in dl
subtract al
move the result in the byte at the address edi+esi
move the byte at the address edi into bl
subtract 0x43
shift left 2
move 0x04030382 in ecx
subtract 0x03030327
load in the stack
shift left by 4 bits of ecx
shift right by 2 the result
add ebx to result
move the byte at the address esi+edi into al
if the value is not equal to 0xbb
jump to shellcode