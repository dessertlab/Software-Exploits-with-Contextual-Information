move the byte at the address esi + eax into bl _BREAK if the value is equal to 0xaa _BREAK jump to shellcode
if bl is equal to 0xbb _BREAK jump to xordecode _BREAK else jump to notdecode
move the byte at the address esi+eax*1 into bl _BREAK if the result of xor operation between the register and 0xaa is not zero _BREAK jump to EncodedShellcode
move the byte at the addrss in esi+ecx+1 to bl _BREAK subtract 0x7 from the registe _BREAK move the result into the byte at the address esi+ecx
in decode move the current byte of the shellcode to the bl register _BREAK perform the xor operation between the register and 0xBB _BREAK if is zero jump to formatting
move the byte of the shellcode to cl _BREAK perform the xor operation between the register and 0xAA _BREAK if the result is zero jump to shift_decode
move the byte in esi+1 to dl _BREAK right shift the register by 1 bit positions _BREAK move the result into the byte at the address esi+1
move the byte in eax to bl _BREAK perform the xor operation between the register and 0xBB _BREAK if the result is zero jump to encoded
move the byte in eax to cl _BREAK perform the xor operation between the register and 0xAA _BREAK if the result is not zero jump to Next_Cycle
move the byte at address eax to dl _BREAK perform the xor operation between the register and 0xBB _BREAK if the result is zero jump to Next_Cycle
mov the word at the address edi+1+ecx into ax _BREAK perform xor operation between the register and bx _BREAK move the result into the word at the address edi
load encoded_shellcode's byte pointed by ESI in al _BREAK swap with next byte value (ESI+1) _BREAK load swapped byte to location pointed by ESI
NOT operation of current byte in esi _BREAK ADD 0x02 and XOR with 0x97 _BREAK ADD 0x10 and XOR with 0x88
left rotate byte [esi] by 4 bits positions _BREAK negate the result _BREAK add 2 to the result
move 0x04030382 to ecx _BREAK subtract 0x03030303 from the register _BREAK load the register in the stack
clear the ebx register _BREAK if the value is equal to eax _BREAK jump to download
clear the ebx register _BREAK if the value is not equal to eax _BREAK jump to retry
perform the AND operation between ax and cx _BREAK if the result is not equal bx _BREAK jump to .l3
increment bl _BREAK if it is less than 0x1f _BREAK jump to 0xf3
increment ebx _BREAK if the result is equal edx _BREAK jump to 0x8
move eax to edx _BREAK right shift the register by byte 16 _BREAK add the result to eax
move 0x72702f2f to esi _BREAK load in the stack _BREAK zero out the register
zero out the register ebx _BREAK if it is equal eax _BREAK jump to exit
zero out the register edi _BREAK if it is not equal eax _BREAK jump to 804808e
zero out the register ebx _BREAK load in the stack _BREAK increment
add 4 to esi _BREAK if the value at its address is equal to edx _BREAK jump to find_egg
move 876189623 to edi _BREAK doubles its value _BREAK load in the stack
if the byte at the address esi is greater than 0x2 _BREAK jump to L1 _BREAK else add 0x2
increment eax _BREAK repeat _BREAK repeat
load eax in the stack _BREAK if is equal ebx _BREAK jump to child
move 0x8b90909d to eax _BREAK negate the result _BREAK load in the stack
move 0x9a8dd091 to eax _BREAK negate the result _BREAK load in the stack
move 0x969d8cd0 to eax _BREAK negate the result _BREAK load in the stack
if the byte at the address esi is lower than 0x1 _BREAK jump to L1 _BREAK else subtract 0x1
zero out eax _BREAK if it is equal edx _BREAK jump to l3
move 0xb33fb33f in eax _BREAK subtract 0x3bd04ed _BREAK load in the stack
load eax in the stack _BREAK clear the register _BREAK move 1 in its lowest byte
clear eax register and move in its lower byte 0x3f _BREAK if it is greater than or equal 9 _BREAK jump to l1
increment ecx _BREAK if is not equal 4 _BREAK jump to loop
clear ecx _BREAK subtract the result from eax and if it is not zero _BREAK jump to cleanup
left shift the register eax by 28 bits positions _BREAK right shift the result by 24 bits positions _BREAK add ebx to result
move 0xff to bl _BREAK subtract al from the result _BREAK move the result in the byte at the address edi
move the value at the address esi to bl _BREAK if the XOR operation between the register and 0xBB is zero _BREAK jump to formatting
move the value at the address esi to cl _BREAK if the XOR operation between the register and 0xAA is zero _BREAK jump to shift_decode
move the value at the address esi+1 to dl _BREAK right shift the register by 1 bit positions _BREAK move the result to the byte at the address esi+1
move the value at the address eax to bl _BREAK if if the XOR operation between the register and 0xBB is zero _BREAK jump to encoded
move the value at the address eax to bl and into cl _BREAK if if the XOR operation between the register and 0xAA is not zero _BREAK jump to Next_Cycle
move the value at the address eax to dl _BREAK if the XOR operation between the register and 0xBB is zero _BREAK jump to Next_Cycle
clear ebx _BREAK if it is equal eax _BREAK jump to child
clear ecx _BREAK move 0x3 in its lowest byte _BREAK decrement it
move the byte at the address edi to the lowest byte of eax _BREAK subtract 0x41 from the register _BREAK left shift the result by 4 bits positions
add the byte at the address edi to the lowest byte of eax _BREAK subtract 0x41 from the result _BREAK move the result to the byte at the address esi
decrement esp _BREAK decrement it _BREAK repeat
increment bl _BREAK if its value is below of 0x1f _BREAK jump to 0xf3
increment ebx _BREAK if its value ie equal edx _BREAK jump to 0x8
perform the AND operation between ax and cx _BREAK if the result is not equal to bx _BREAK jump to .l3
move the value at the address esi into al _BREAK decrement the result _BREAK move the result to the value at the address esi
exchange ebx and eax _BREAK repeat _BREAK repeat
perform if the XOR operation between the value at the address eax and ah _BREAK perform the AND operation between the result and the value at the address eax _BREAK repeat
perform the AND operation between ah and the value at the address eax _BREAK repeat _BREAK repeat
move esp to the value at the address eax _BREAK perform the AND operation between the register and ah _BREAK repeat
negate bl _BREAK perform the XOR operation between the result and al _BREAK move the result to the value at the address in edi+ecx
move the byte at the address edi to al _BREAK subtract 0x41 from the result _BREAK left shift the result by 4 bits positions
add the byte at the address edi to al _BREAK subtract 0x41 from result _BREAK move the result to the byte at the address esi
clear ecx _BREAK if the register is equal eax _BREAK jump to 0x83
increment edx _BREAK left shift the register by 10 bits positions _BREAK increment it
exchange ecx and eax _BREAK repeat _BREAK repeat
increment esp _BREAK repeat _BREAK repeat
load esi in the stack _BREAK decrement the register _BREAK increment the register
exchange edx with eax _BREAK decrement it _BREAK move the result in ecx
move the value at the address esp+ecx to ebx _BREAK move the register to edx _BREAK right shift the register by 28 bits positions
move the value at the address edx to ax _BREAK if the register is not equal 0x5a4d _BREAK jump findMZ
move the byte at the address eax+ecx+5 to bl _BREAK if the register is equal 0 _BREAK jump foundPtr
move the value at the address edi+0x20 to eax _BREAK add ebx to the register _BREAK move the result to the value at the address ebp+4
move the the value at the address edx+4*ecx to eax _BREAK add ebx to result _BREAK move the result to the value at the address esp+0x1c
move 0x1111 into bx _BREAK subtract 0x1010 from the register _BREAK move the result to the word at the address esp+0x3c
left rotate byte [esi] by 4 _BREAK negate the result _BREAK add 4 to result
move the byte at the address esi+eax+1 to bl _BREAK move the register to the byte at the address edi _BREAK perform the XOR operation between the register and 0XDD
move the byte at the address esi+eax+1 to bl _BREAK move the register to the byte at the address edi _BREAK negate the result
clear ebx _BREAK if eax is equal to the register _BREAK jump to download
move the byte at the address esi+eax*3 into bl _BREAK if the result of xor operation between the register and 0xaa is not zero _BREAK jump to shellcode
add 4 to esi _BREAK if the value at its address is equal to eax _BREAK jump to find_egg
clear ecx _BREAK subtract the result from ebx and if it is not zero _BREAK jump to clean
load ebx in the stack _BREAK clear the register _BREAK move 1 in its lowest byte
if the byte at the address esi+eax*3 is greater than 0x2 _BREAK jump to L1 _BREAK else add 0x2
move the value at the address eax into bl and into cl _BREAK if the XOR operation between the register and 0xDD is not zero _BREAK jump to Cycle
if cl is equal to 0xbb _BREAK jump to xordecode _BREAK else jump to notdecode
move the byte at the address esi+ebx*1 into al _BREAK if the result of xor operation between the register and 0xaa is not zero _BREAK jump to EncodedShellcode
move the byte at the adderss in esi+eax+1 to bl _BREAK subtract 0x9 from the register _BREAK move it into the byte in esi+eax
in decode move the current byte of the shellcode to the al register _BREAK perform the xor operation between the register and 0xDD_BREAK if the result is zero jump to format
move the byte of the shellcode to bl _BREAK perform the xor operation between the register and 0xBB _BREAK if the result is zero jump to shift
move the byte at the address esi+1 to dl _BREAK right shift the register by 1 bit positions _BREAK move the result into the byte at the address esi+3
move the byte at the address ebx to al _BREAK perform the xor operation between the register and 0xBB _BREAK if the result is zero jump to encodedTwo
move the byte at the address eax to bl _BREAK perform the xor operation between the register and 0xAA _BREAK if the result is not zero jump to Next
move the byte at address eax to bl _BREAK perform the xor operation between the register and 0xBB _BREAK if the result is zero jump to CycleNext
mov the word at the address edi+1+ecx into bx _BREAK perform the xor operation between the register and bx _BREAK move the result into the word at the address edi+1
load encoded_shellcode's byte pointed by ESI in al _BREAK swap with next byte value (ESI+2) _BREAK load swapped byte to location pointed by ESI+1
left rotate byte [esi] by 4 _BREAK negate the result _BREAK add 5 to the result
move 0x04030382 to ecx _BREAK subtract 0x03030303 from the register _BREAK load the register in the stack
clear the eax register _BREAK if the value is equal to ecx _BREAK jump to downloadtwo
clear the ebx register _BREAK if the value is not equal to ecx _BREAK jump to retrytwo
perform the AND operation between bx and cx _BREAK if the result is not equal ax _BREAK jump to .l7
increment al _BREAK if the register is less than 0x1f _BREAK jump to 0xf4
increment ebx _BREAK if the result is equal edx _BREAK jump to 0x9
move ebx to edx _BREAK right shift by byte 16 _BREAK add the result to ebx
move 0x72702f2f to esi _BREAK load the register in the stack _BREAK clear the register
zero out the register eax _BREAK if it is equal ebx _BREAK jump to exittwo
zero out the register edi _BREAK if it is not equal ebx _BREAK jump to 804800e
zero out the register ecx _BREAK load in the stack _BREAK increment
add 4 to esi _BREAK if the value at its address is equal to ebx _BREAK jump to find_eggtwo
move 876198623 to edi _BREAK doubles its value _BREAK load in the stack
if the byte at the address esi is greater than 0x2 _BREAK jump to L1 _BREAK else add 0x5
increment ecx _BREAK repeat _BREAK repeat
load ecx in the stack _BREAK if is equal eax _BREAK jump to childtwo
move 0x8b90909d to ebx _BREAK negate the result _BREAK load in the stack
move 0x9a8dd091 to ecx _BREAK negate the result _BREAK load in the stack
move 0x989d7cd0 to eax _BREAK negate the result _BREAK load in the stack
if the byte at the address esi is lower than 0x1 _BREAK jump to L1 _BREAK else subtract 0x2
zero out eax _BREAK if it is equal edx _BREAK jump to l5
move 0xb33fb33f to ebx _BREAK subtract 0x3bd04ed from the register _BREAK load in the stack
load eax in the stack _BREAK clear the register _BREAK move 7 to its lowest byte
clear eax register and move to its lower byte 0x3f _BREAK if it is greater than or equal 5 _BREAK jump to l2
increment ecx _BREAK if is not equal 7 _BREAK jump to loop
clear ecx _BREAK subtract the result from ebx and if it is not zero _BREAK jump to cleanuptwo
left shift the register eax by 28 bits positions _BREAK right shift the result by 24 bits positions _BREAK add ecx to result
move 0xff to bl _BREAK subtract al from the register _BREAK move the result to the byte at the address edi+1
move the value at the address esi+1 to bl _BREAK if the XOR with 0xBB is zero _BREAK jump to formattingtwo
move the value at the address esi+eax*1 to cl _BREAK if the XOR operation between the register and 0xAA is zero _BREAK jump to shift_decodetwo
move the value at the address esi+1 to dl _BREAK right shift the register by 1 bit positions _BREAK move the result to the byte at the address esi+eax*2
move the value at the address eax to cl _BREAK if the XOR operation between the register and 0xBB is zero _BREAK jump to encodedth
move the value at the address eax to bl and in cl _BREAK if the XOR operation between the register and 0xDD is not zero _BREAK jump to Next_Cycle
move the value at the address eax to dl _BREAK if the XOR operation between the register and 0xBB is not zero _BREAK jump to Next_Cycle
clear eax _BREAK if it is equal ecx _BREAK jump to child
clear eax _BREAK move 0x3 to its lowest byte _BREAK decrement the register
move the byte at the address edi to al _BREAK subtract 0x43 from the register _BREAK left shift the result by 7 bits positions
add the byte at the address edi to al _BREAK subtract 0x41 from the register _BREAK move the result to the byte at the address esi+ebx
decrement esi _BREAK repeat _BREAK repeat
increment bl _BREAK if its value is below of 0x1f _BREAK jump to 0xf5
increment ebx _BREAK if its value ie equal edx _BREAK jump to 0x9
perform the AND operation between ax and bx _BREAK if the result is not equal to cx _BREAK jump to .l8
move the value at the address esi into al _BREAK decrement the result _BREAK move the result to the value at the address esi+ecx
exchange ecx and eax _BREAK repeat _BREAK repeat
perform the AND operation between ah and the value at the address eax+ecx _BREAK repeat _BREAK repeat
move esp to the value at the address eax+ebx*2 _BREAK perform the AND operation between the register and ah _BREAK repeat
negate bl _BREAK perform the XOR operation between the result and al _BREAK move the result to the value at the address in edi
move the byte at the address edi to al _BREAK subtract 0x41 from the register _BREAK left shift the result by 2 bits positions
add the byte at the address edi+ecx to al _BREAK subtract 0x41 from the result _BREAK move the result to the byte at the address esi+ecx
clear ecx _BREAK if the register is equal eax _BREAK jump to 0x85
increment edx _BREAK  left shift the register by 9 bits positions _BREAK increment it
exchange ebx with eax _BREAK decrement the result _BREAK move the result to ecx
move the value at the address esp+ecx to ebx _BREAK move the register to edx _BREAK right shift the result by 24 bits positions
move the value at the address edx to ax _BREAK if the register in not equal 0x5a7d _BREAK jump findMZM
move the byte at the address eax+ecx*5 to bl _BREAK if the register is equal 0 _BREAK jump foundPtrM
move the value at the address edi+0x20 to eax _BREAK add ebx to the register _BREAK move the result to the value at the address ebp+eax*4
move the the value at the address edx+4*ecx to ebx _BREAK add eax to result _BREAK move the result to the value at the address esp+0x1c
move 0x1111 into cx _BREAK subtract 0x1010 from the result _BREAK move the result to the word at the address esp+0x3c
left rotate byte [esi] by 4 _BREAK negate the result _BREAK add 8 to the result
move the byte at the address esi+eax+1 to bl _BREAK move the register to the byte at the address edi _BREAK perform the XOR operation between the register and 0XAA
move the byte at the address esi+eax*2 to bl _BREAK move the register to the byte at the address edi _BREAK negate the result
clear ecx _BREAK if eax is equal to the register _BREAK jump to downloadtwo
move the byte at the address esi+eax into bl _BREAK if the result of xor operation between the register and 0xbb is not zero _BREAK jump to shellcodetwo
add 5 to esi _BREAK if the value at its address is equal to eax _BREAK jump to find_eggtwo
clear eax _BREAK subtract the result from ebx and if it is not zero _BREAK jump to cleantwo
load ebx in the stack _BREAK clear the register _BREAK move 7 in its lowest byte
if the byte at the address esi+eax*5 is greater than 0x2 _BREAK jump to L1 _BREAK else add 0x2
move the value at the address eax to bl and to cl _BREAK if the XOR operation between the register and 0xBB is not zero _BREAK jump to Cycle
move the byte at the address esi+eax into cl _BREAK if the register is equal to 0xaa _BREAK jump to shellcode
if cl is equal to 0xbb _BREAK jump to xordecode _BREAK else jump to nodecode
move the byte at the address in esi+ecx+1 to al _BREAK subtract 0x7 from the register _BREAK move the result into the byte in esi+ecx
move the byte in esi+1 to bl _BREAK right shift the register by 1 bit position _BREAK move the result into the byte in esi+1
move the byte in eax to dl _BREAK perform xor operation between the register and 0xBB _BREAK if is zero jump to encod
move the byte in eax to dl _BREAK perform xor operation between the register and 0xAA _BREAK if the result is not zero jump to CycleProx
mov the word at the address edi into ax _BREAK perform xor operation between the register and bx _BREAK move the result into the word in edi+1
load encoded_shellcode's byte pointed by ESI in dl _BREAK swap with next byte value (ESI+1) _BREAK load swapped byte to location pointed by ESI
rotate left byte [edi] by 4 _BREAK negate the result _BREAK add 2
move 0x04030382 to eax _BREAK subtract 0x03030303 from the register _BREAK load in the stack
clear the edx register _BREAK if the register is equal to eax _BREAK jump to dld
clear the edi register _BREAK if the register is not equal to edx _BREAK jump to ret
perform the and operation between ax and bx _BREAK if the result not equal cx _BREAK jump to l4
increment dl _BREAK if the register is less than 0x1f _BREAK jump to 0xf3
increment edx _BREAK if the result is equal eax _BREAK jump to 0x81
move ecx into edx _BREAK right shift by byte 16 _BREAK add the result to ebx
move 0x72702f2f to edi _BREAK load in the stack _BREAK zero out the register
clear edx _BREAK if it is equal ecx _BREAK jump to ext
zero out the register esi _BREAK if it is not equal eax _BREAK jump to 804808e
add 4 to edi _BREAK if the value at its address is equal to edx _BREAK jump to find
increment edi _BREAK repeat _BREAK repeat
load edx in the stack _BREAK if is equal edx _BREAK jump to child
move 0x9a8dd090 to edx _BREAK negate the result _BREAK load in the stack
if the byte at the address edi is lower than 0x1 _BREAK jump to L7 _BREAK else subtract 0x1
load edx in the stack _BREAK clear the register _BREAK move 4 in its lowest byte
clear ecx _BREAK subtract the result from edx and if it is not zero _BREAK jump to clean
left shift the register edx by 28 bits positions _BREAK right shift the result by 24 bits positions _BREAK add ebx to result
move 0xff to dl _BREAK subtract bl from the register _BREAK move the result to the byte at the address edi
move the value at the address esi to dl _BREAK right shift the register by 1 bit position  _BREAK move the result to the byte at the address esi
move the value at the address eax to cl _BREAK if the xor operation between the result and 0xBB is zero _BREAK jump to encod
add the byte at the address esi to the lowest byte of eax _BREAK subtract 0x41 from the register _BREAK move the result to the byte at the address edi
perform the and operation between eax and ebx _BREAK repeat _BREAK repeat
negate dl _BREAK perform the xor operation between the result and al _BREAK move the result to the value at the address in ecx
add the byte at the address edi+esi to bl _BREAK subtract 0x41 from the register _BREAK move the result to the byte at the address esi
exchange eax and ebx _BREAK repeat _BREAK repeat
increment edx _BREAK repeat _BREAK repeat
load edi in the stack _BREAK decrement the register _BREAK increment the register
move the value at the address esp+ecx to eax _BREAK move the register to edx _BREAK right shift the register by 4 bits positions 
move the the value at the address edx+ecx to eax _BREAK add eax to result _BREAK move the result to the value at the address esp+0x1c
move the byte at the address eax to cl _BREAK move the register to the byte at the address esi _BREAK perform the xor operation between the register and 0XDD
load ecx in the stack _BREAK clear the register _BREAK move 1 in its lowest byte
clear eax _BREAK subtract the result from ecx and if it is not zero _BREAK jump to new
add 4 to edi _BREAK if the value at its address is equal to eax _BREAK jump to label
move the byte at the address esi into bl _BREAK if the result of xor operation between the register and 0xaa is not zero _BREAK jump to label2
clear edx _BREAK if eax is equal to the register _BREAK jump to downlo
move the byte at the address esi to cl _BREAK move the register to the byte at the address edi _BREAK perform the xor operation betweenthe register and 0XDD
move 0x1011 into ax _BREAK subtract 0x1000 from the register _BREAK move the result to the word at the address esp
move the byte at the address eax+ecx to cl _BREAK if the register is equal 0 _BREAK jump found
move edx to ax _BREAK if the register is not equal 0x5a7d _BREAK jump findS
negate cl _BREAK perform the xor operation between the result and al _BREAK move the result to the value at the address in edi+ebx
move the valute at the address esi into dl _BREAK decrement the result _BREAK move the result to the value at the address esi
perform the and operation between bx and cx _BREAK if the result is not equal to ax _BREAK jump to l27
increment dl _BREAK if the value of the register is below of 0xf3 _BREAK jump to 0x1f
move the value at the address ecx+ebx to al _BREAK if the xor operation between the register and 0xBB is zero _BREAK jump to advance
move esi to bl _BREAK if the xor operation between the register and 0xAA is zero _BREAK jump to form
move 0xb33fb33f to ecx _BREAK subtract 0x3bd04ed from the register _BREAK load in the stack 
move 0x9a8dd110 to edx _BREAK negate the result _BREAK load in the stack
move the byte at the address edi to cl _BREAK swap with next byte value (ESI+1) _BREAK load swapped byte to location pointed by ESI
move the byte at the address esi+eax into dl _BREAK if the result of xor operation between the register and 0xbb is not zero _BREAK jump to shencoded
move eax to ecx _BREAK right shift the register by byte 4 _BREAK add the result to eax
move 0x72702f2f to edx _BREAK load in the stack _BREAK zero out the register
if the byte at the address esi is greater than 0x1 _BREAK jump to L3 _BREAK else add 0x1
perform the or operation between eax and ah _BREAK perform the and operation between the result and eax _BREAK repeat
perform the and operation between ah and the value at the address eax _BREAK repeat _BREAK repeat
move the byte at the address edi into dl _BREAK subtract 0x43 from the register _BREAK left shift the result by 2 bits positions
increment edx _BREAK repeat _BREAK repeat
load ebx in the stack _BREAK decrement the register _BREAK increment the register
move the value at the address esp to ecx _BREAK move the register to edx _BREAK right shift the register by 4 bits positions
move the the value at the address edx+4*ecx to edx _BREAK add ebx to result _BREAK move the result to the value at the address esp+0x1c
move 0xff to dl _BREAK subtract al from the register _BREAK move the result to the byte at the address edi+esi
move the byte at the address edi into bl _BREAK subtract 0x43 from the register _BREAK left shift the result by 2 bits positions
move 0x04030382 to ecx _BREAK subtract 0x03030327 from the register _BREAK load the result in the stack